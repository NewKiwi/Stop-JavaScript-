## 前言
在“手握绳索”篇章中简单地说了作用域的概念，可作用域远远不止如此

前面篇章我们将“作用域”定义为一套规则，用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找（标识符查询，变量查询使用标识符查询）。

以下参考《JavaScript高级程序设计》和《你不知道的JavaScript》上卷
## 工作模型
What：
- 第一种是最为普遍的，被大多数编程语言所采用的词法作用域（Javascript使用该作用域）
- 另外一种叫作动态作用域，仍有一些编程语言在使用(比如 Bash 脚本、Perl 中的一些模式等)。

### 词法作用域
编译器的第一个工作阶段叫做词法化（也叫单词化），词法化的过程会对源代码中的字符进行检查，如果是有状态的解析过程，还会赋予单词语义。
词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变(大部分情况下是这样的)（除了eval和with）。

### 查找（重温作用域链）
- 作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫作“遮蔽效应”(内部的标识符“遮蔽”了外部的标识符)（类似于对象属性和方法在原型链中的查找）
- 遮蔽的全局变量可以通过window对象访问，遮蔽的局部变量除非使用闭包，否则无法访问。

### “欺骗”词法作用域
What:何谓"欺骗",词法作用域是由你在写代码时将变量写在哪里来决定的,假如动态地在词法作用域中创建新的变量，产生了“遮蔽效应”（eval），或者将将一个对象处理为词法作用域，产生了“遮蔽效应”或者还创建了当前作用域的变量(非严格模式)（with)。

How:eval通常用来执行动态创建的代码。
如果 eval(..) 中所执行的代码包含有一个或多个声明(无论是变量还是函 数)，就会对 eval(..) 所处的词法作用域进行修改（例如，声明了一个新的变量）。在严格模式的程序中，eval(..) 在运行时有其自己的词法作用域，意味着其 中的声明无法修改所在的作用域。

eval(..) 函数如果接受了含有一个或多个声明的代码，就会修改其所处的词法作用域，而 with 声明实际上是根据你传递给它的对象凭空创建了一个全新的词法作用域。

两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。

### 延长作用域链
- with语句
- try-catch语句的 catch 块（对 catch 语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。）

#### 由没有块级作用域到创建块级作用域
在其他类 C 的语言中，由花括号封闭的代码块都有自己的作用域(如果用ECMAScript的话来讲，就是它们自己的执行环境)，因而支持根据条件来定义变量。但是JavaScript中通常只有全局作用域和函数作用域（不考虑特殊情况下，通常只能由函数创建作用域, 而没有块级作用域，就会使代码实际运行结果和代码语义有点不同，例如循环的循环变量）。

那么如何创建块级作用域呢？with不提倡使用，ES6可以使用let,通用的方式可使用try-catch作为一个替代方案。
（提出疑问：babel转换ES6，块级作用域是否用的try-catch作为替代方案？还是使用了IIFE？）
（
我觉得是try-catch，因为IIFE和try-catch并不等价，
- this/return/break/continue等语句发生变化（IIFE）
- IIFE 并不是一个普适的解决方案，它只适合在某些情况下进行手动操作。
）
```javascript
{
  let a = 2;
  console.log( a ); // 2
}
console.log( a ); // ReferenceError
```
```javascript
try{throw 2;}catch(a){ console.log( a ); // 2
}
console.log( a ); // ReferenceError
```

## 函数作用域
What:函数作用域是指属于这个函数的全部变量都可以在整个函数的范围内使用及复用(事实上在嵌套的作用域中也可以使用)。这种设计方案是非常有用的，能充分利用 JavaScript 变量可以根据需要改变值类型的“动态”特性。

### 用函数作用域来遵循最小授权原则和实现规避环境污染

#### 最小授权原则
在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计。（最小接口原则？）

#### 规避环境污染
变量的定义不污染当前环境。例如：
```javascript
var a = 2;
function foo() { // <-- 添加这一行
  var a = 3; 
  console.log( a ); // 3
} // <-- 以及这一行
foo(); // <-- 以及这一行
console.log( a ); // 2
```
foo已经污染了当前环境，如果在全局作用域中，可能会造成很大的影响
假如如果函数不需要函数名(或者至少函数名可以不污染所在作用域)，并且能够自动运行：
```javascript
var a = 2;
(function foo(){ // <-- 添加这一行
var a = 3;
console.log( a ); // 3 
})(); // <-- 以及这一行
 console.log( a ); // 2
```

##### 函数表达式来实现规避环境污染
函数表达式和函数声明的区别：最简单的方法是看 function 关键字出现在声明中的位 置(不仅仅是一行代码，而是整个声明中的位置)。如果 function 是声明中 的第一个词，那么就是一个函数声明，否则就是一个函数表达式。

以“规避环境污染”一节为例，(function foo(){ .. })作为函数表达式意味着foo只能在..所代表的位置中 被访问，外部作用域则不行。foo 变量名被隐藏在自身中意味着不会非必要地污染外部作用域。
另一个例子，回调参数：
```javascript
setTimeout( function() {
  console.log("I waited 1 second!");
}, 1000 );
```
这叫作匿名函数表达式，因为 function().. 没有名称标识符。函数表达式可以是匿名的，而函数声明则不可以省略函数名——在 JavaScript 的语法中这是非法的。
但始终给函数表达式命名是一个最佳实践:
```javascript
setTimeout( function timeoutHandler() { // <-- 快看，我有名字了! 
console.log( "I waited 1 second!" );
}, 1000 );
```
因为匿名函数表达式有以下缺点：
- 省略了对于代码可读性/可理解性很重要的函数名
- 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难
- 如果没有函数名，当函数需要引用自身时只能使用已经过期的arguments.callee引用，比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。

“规避环境污染”一节，使用了立即执行函数表达式（IIFE ）。一个非常普遍且进阶的用法是把它们当作函数调用并传递参数进去（很多框架和库都是这样做的）。除了规避环境污染，这种方式还有其他用法：
1、解决 undefined 标识符的默认值被错误覆盖导致的异常(虽然不常见)。
```javascript
undefined = true; // 给其他代码挖了一个大坑!绝对不要这样做! 
(function IIFE( undefined ) {
var a;
if (a === undefined) {
             console.log( "Undefined is safe here!" );
         }
})();
```
2、倒置代码的运行顺序
IIFE 还有一种变化的用途是倒置代码的运行顺序，将需要运行的函数放在第二位，在 IIFE 执行之后当作参数传递进去。这种模式在 UMD(Universal Module Definition)项目中被广 泛使用。尽管这种模式略显冗长，但有些人认为它更易理解。
```javascript
var a = 2;
(function IIFE( def ) { 
  def( window );
})(function def( global ) {
var a = 3;
console.log( a ); // 3 console.log( global.a ); // 2
});
```
函数表达式 def 定义在片段的第二部分，然后当作参数(这个参数也叫作 def)被传递进 IIFE 函数定义的第一部分中。最后，参数 def(也就是传递进去的函数)被调用，并将 window 传入当作 global 参数的值。

#### 块作用域
块作用域是用来遵循最小授权原则和实现规避环境污染的最佳方法。而通常for循环和条件语句中的变量都是属于外部作用域。