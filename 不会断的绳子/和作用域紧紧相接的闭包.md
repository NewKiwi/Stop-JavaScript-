## 前言
以下参考《JavaScript高级程序设计》和《你不知道的JavaScript》上卷

闭包是和作用域紧紧相联系的，闭包可以称为作用域闭包。有不少开发人员总是搞不清匿名函数和闭包这两个概念，因此经常混用。而匿名函数可以说是用来实现闭包的其中一种方式（具名函数也可以）。闭包是指有权访问另一个<b>函数作用域中的变量</b>的<b>函数</b>。
创建闭包的常见方式，就是在一个函数内部创建另一个函数。

闭包可以说是在代码中随处可见。
闭包是基于词法作用域书写代码时所产生的自然结果，你甚至不需要为了利用它们而有意识地创建闭包。闭包的创建和使用在你的代码中随处可见。你缺少的是根据你自己的意愿来识别、拥抱和影响闭包的思维环境。

## 确定概念
闭包是指有权访问另一个<b>函数作用域中的变量</b>的<b>函数</b>。这句话就是闭包的定义了吗？仔细看一下，其实可以发现用这句话来定义闭包并不完整（如果把“有权”看做是能在当前词法作用域之外有权就是完整的），例如：
```javascript
function foo() { 
  var a = 2;
  function bar() { 
    console.log( a ); // 2
  }
  bar(); 
}
foo();
```
bar函数是闭包吗？准确来说不是的，有权访问foo函数作用域的变量是因为作用域的查询。（但作用域的查询只是闭包的一部分）

准确地说，闭包是函数，而当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。

例如：
```javascript
function foo() { 
  var a = 2;
  function bar() { 
    console.log( a );
  }
  return bar;
}
var baz = foo();
baz(); // 2 —— 朋友，这就是闭包的效果。
```
函数 bar() 的词法作用域能够访问 foo() 的内部作用域。然后我们将 bar() 函数本身当作<b>一个值类型</b>进行传递。在foo()执行后，其返回值(也就是内部的bar()函数)赋值给变量baz并调用baz()，实际上只是<b>通过不同的标识符</b>引用调用了内部的函数bar()。

在 foo() 执行后，通常会期待 foo() 的整个内部作用域都被销毁，因为我们知道引擎有垃 圾回收器用来释放不再使用的内存空间。由于看上去 foo() 的内容不会再被使用，所以很 自然地会考虑对其进行回收。
而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此 没有被回收。谁在使用这个内部作用域?原来是 bar() 本身在使用。
拜 bar() 所声明的位置所赐，它拥有涵盖foo()内部作用域的闭包，使得该作用域能够一直存活，以供 bar() 在之后任何时间进行引用。<b>这段话我理解是，当代码有闭包时，代码在编译阶段就确定了闭包的存在?而不是执行时？从而使这个作用域一直保留着？（需更深入理解JS的编译过程）</b>
bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。

## 更多产生闭包的方式
1、通过对函数类型的值进行传递，当函数在别处被调用时
```javascript
function foo() { 
  var a = 2;
  function baz() { 
    console.log( a ); // 2
  }
  bar( baz ); 
}
function bar(fn) {
  fn(); // 妈妈快看呀，这就是闭包!
}
```
也可以间接传递函数,而不是通过参数
```javascript
var fn;
function foo() {
  var a = 2;
  function baz() { 
    console.log( a );
  }
  fn = baz; // 将 baz 分配给全局变量 
}
function bar() {
  fn(); // 妈妈快看呀，这就是闭包!
}
foo();
bar(); // 2
```

## 更进一步
```javascript
function wait(message) {
         setTimeout( function timer() {
             console.log( message );
}, 1000 ); }
wait( "Hello, closure!" );
```
将一个内部函数(名为 timer)传递给 setTimeout(..)。timer 具有涵盖 wait(..) 作用域的闭包，因此还保有对变量 message 的引用。
wait(..) 执行 1000 毫秒后，它的内部作用域并不会消失，timer 函数依然保有 wait(..)作用域的闭包。
深入到引擎的内部原理中，内置的工具函数 setTimeout(..) 持有对一个参数的引用，这个 参数也许叫作 fn 或者 func，或者其他类似的名字。引擎会调用这个函数，在例子中就是 内部的 timer 函数，而词法作用域在这个过程中保持完整。
(在这个例子中，我认为setTimeout声明时所在的作用域一直都没有被回收，除非将setTimeout(..) 持有对一个参数的引用设为null)

或者，如果你很熟悉 jQuery(或者其他能说明这个问题的 JavaScript 框架)，可以思考下面 的代码:
```javascript
function setupBot(name, selector) {
  $( selector ).click(function activator() {
    console.log( "Activating: " + name );
  });
}
setupBot( "Closure Bot 1", "#bot_1" );
setupBot( "Closure Bot 2", "#bot_2" );
```
玩笑开完了，本质上无论何时何地，如果将函数(访问它们各自的词法作用域)当作第一 级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、 Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步(或者同步)任务中，只要使 用了回调函数，实际上就是在使用闭包!

## 典型的闭包IIFE?
通常认为 IIFE 是典型的闭包例子，但根据先前对 闭包的定义，我并不是很同意这个观点。
```javascript
var a = 2;
(function IIFE() { 
  console.log( a );
})();
```
虽然这段代码可以正常工作，但严格来讲它并不是闭包。为什么?因为函数(示例代码中 的 IIFE)并不是在它本身的词法作用域以外执行的。它在定义时所在的作用域中执行(而 外部作用域，也就是全局作用域也持有 a)。a 是通过普通的词法作用域查找而非闭包被发 现的。
尽管技术上来讲，闭包是发生在定义时的，但并不非常明显，就好像六祖慧能所说:“既 非风动，亦非幡动，仁者心动耳。”
尽管 IIFE 本身并不是观察闭包的恰当例子，但它的确创建了闭包，并且也是最常用来创建可以被封闭起来的闭包的工具。因此 IIFE 的确同闭包息息相关，即使本身并不会真的使用 闭包。

所以说，闭包的定义是有些含糊的，但按确定的定义“闭包是函数，而当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。”来判断，符合的就一定是闭包。