以下参考《你不知道的JavaScript》上卷

## 赋值操作和获取源值，借助作用域
（以var a = 2为例）编译器生成代码后，引擎执行时，会通过查找变量a来判断它是否已声明过（词法分析已经产生了词法作用域）。查找的过程由作用域进行协助，但是引擎执行怎样的查找，会影响最终的查找结果。

引擎在作用域中进行查询的方式有两种：
- LHS查询
- RHS查询

分别代表左侧和右侧。当变量出现在赋值操作的左侧时进行 LHS 查询，出现在右侧时进行RHS查询。讲得更准确一点，RHS 查询与简单地查找某个变量的值别无二致，而 LHS 查询则是试图 找到变量的容器本身，从而可以对其赋值。从这个角度说，RHS 并不是真正意义上的“赋 值操作的右侧”，更准确地说是“非左侧”。

即:LHS查询用来进行赋值操作，RHS查询用来获取变量的值。

### 关于函数声明是LHS查询还是RHS查询
你可能会倾向于将函数声明 function foo(a) {... 概念化为普通的变量声明 和赋值，比如 var foo、foo = function(a) {...。如果这样理解的话，这 个函数声明将需要进行 LHS 查询。 然而还有一个重要的细微差别，编译器可以在代码生成的同时处理声明和值的定义，比如在引擎执行代码时，并不会有线程专门用来将一个函数值“分 配给”foo（即执行前已经分配?）。因此，将函数声明理解成前面讨论的 LHS 查询和赋值的形式并不合适。

### 认知一个简单的过程
```javascript
function foo(a) { 
  console.log( a ); // 2
}
foo( 2 );
```
（作用域贯彻始终，作用域这里简写为Z，引擎简写为Y）
（在这之前，编译器已经编译且声明了foo，为一个函数，已经把a声明为 foo 的一个形式参数）
Y要执行foo(2) -> Y向Z进行RHS查询,拿到foo -> Y开始执行foo -> Y向Z进行LHS查询，为a赋值 -> Y向Z进行RHS查询，获取console内置对象 -> 在console中查找log函数 -> Y向Z进行RHS查询,获取a的值，传递进log函数

### 为什么创建了全局变量
LHS查询和RHS查询都在当前执行作用域中开始，没有找到则向上继续查找目标标识符，直到全局。

LHS查询找到全局作用域都找不到了，就会自动创建一个（就是隐式创建全局变量的背后原理，前提是程序运行在非 “严格模式”下）

### RHS查询和异常
RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 ReferenceError 异常。
RHS 查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作， 比如试图对一个非函数类型的值进行函数调用，或着引用 null 或 undefined 类型的值中的 属性，那么引擎会抛出另外一种类型的异常，叫作 TypeError。

ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对 结果的操作是非法或不合理的。

## 提升
直觉上会认为 JavaScript 代码在执行时是由上到下一行一行执行的。但实际上这并不完全正确，有一种特殊情况会导致这个假设是错误的。

What:提升就好像是变量和函数声明从它们在代码中出现的位置被“移动” 到了最上面（指的是声明所属于的作用域）。

每个作用域都会进行提升操作。
经过“JS是怎么跑起来的”和以上内容，不难知道为什么会提升。

举个例子：
```javascript
a = 2;
var a; 
console.log( a );
```
console.log(..) 声明会输出2
因为上面代码经过编译器编译后，执行时相当于：
```javascript
var a;
a = 2;
console.log( a );
```

而：
```javascript
console.log( a ); 
var a = 2;
```
会输出undefined

### 函数声明提升和函数表达式
以上说的都是变量提升，函数声明也会提升。但函数表达式不会提升。

### 函数优先
函数声明和变量声明都会被提升。但是一个值得注意的细节(这个细节可以出现在有多个“重复”声明的代码中)是函数会首先被提升，然后才是变量。
```javascript
foo(); // 1
var foo;
function foo() { 
  console.log( 1 );
}
foo = function() { 
  console.log( 2 );
};
// 会输出 1 而不是 2 
```
因为实际上var foo之前已经有声明，var foo 被忽略了。