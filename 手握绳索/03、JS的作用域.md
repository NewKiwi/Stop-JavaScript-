## 理解作用域
What:作用域是规则，是根据名称查找变量的规则。

个人认为：
规则包含了两个方面：
- 执行环境查找规则，执行环境可以看做是一个独立范围，在此范围内进行变量查找，例如单单只是全局环境、某个函数的局部环境
- 作用域链查找规则,作用域链的最后一个对象一定是全局作用域,作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。

以下参考《JavaScript高级程序设计》和《你不知道的JavaScript》上卷
### 用执行环境来理解
执行环境(execution context，为简单起见，有时也称为“环境”)是 JavaScript 中最为重要的一个概 念。个人认为，执行环境就是宏观上的作用域，定义了变量或函数有权访问的数据，决定了它们各自的行为(即规则)。

每个执行环境都有一个 与之关联的变量对象(variable object)，环境中定义的所有变量和函数都保存在这个对象中。（可以<b>简单地看做作用域是一个对象</b>）。这个对象代码无法访问，但解析器在处理数据时会在后台使用它。

因此:
- 全局执行环境是最外围的执行环境(宿主环境不同，全局执行环境也有所不同，这也是很多JS库或框架工厂函数中进行全局执行环境判断的原因)
- Web浏览器中，全局执行环境是window对象，所有的全局变量和函数都是作为window对象的属性和方法建立的
- 全局执行环境直到应用程序退出——例如关闭网页或浏览器时才会被销毁。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（除非使用闭包，保留了对变量或函数的引用）

#### 用树结构理解作用域和函数执行
每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。 而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript 程序中的执行流正是由这个方便的机制控制着。

当代码在一个环境中执行时，会创建变量对象的一个作用域链(scope chain)。
作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。
作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象(activation object)作为变量对象。
活动对象在最开始时只包含一个变量，即arguments对象(这个对象在全局环境中是不存在的)。
作用域链中的下一个变量对象来自包含(外部)环境，而再下一个变量对象则来自下一个包含环境。这样，一直延 续到全局执行环境;全局执行环境的变量对象始终都是作用域链中的最后一个对象。
标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止(如果找不到标识符，通常会导致错误发生)。

HOW:
全局执行环境可以抽象成树结构的根部，当执行函数时，就相当于在根部上用<b>变量对象</b>中的<b>argumentsa对象和当前其他执行环境中的变量</b>建造一层分支节点（执行环境），当函数中仍然有函数执行时，就相当于在当前分支上增加分支节点，链接分支节点的线就相当于作用域链（产生了闭包，从闭包是对产生闭包的作用域的引用，所以按作用域链进行标示符查询，即从声明闭包的函数开始），当前分支节点有序访问到的变量和函数的都是从当前分支节点往根部访问。当分支节点所代表的函数执行完后，该分支节点摧毁。

Q:闭包造成的分支节点不被摧毁在树结构的关系是怎样的？我认为是只可以是由分支线的前端立体往上关联分支节点，可以跨节点，可以跨分支。

### 用编译过程来理解
先理解三个基本概念:
- 引擎：从头到尾负责整个JavaScript程序的<b>编译</b>及执行过程。
- 编译器：引擎的好朋友之一，负责语法分析及代码生成等脏活累活（见JS是怎么跑起来的）
- 作用域：引擎的另一位好朋友，负责收集并维护由所有声明的标识符(变量)组成的一系列查 询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限
  
注意，JavaScript程序能跑起来，经历了编译和执行两个过程。

以var a = 2为例子，引擎不是认为这是一个声明，而是两个声明！一个在编译器编译时处理，一个在引擎运行时处理。

var a = 2会被编译器分解成词法单元，再解析成抽象语法树，然后生成代码，可是生成代码可能跟我们预期想的有些不同，它是这样的：
- 遇到var a,询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中，如果是，编译器会忽略该声明，继续进行编译;否则它会要求作用域在当前作用域的集合中声明一个新的变量并命名为 a。
- 然后生成引擎运行时所需要的代码，这些代码是用来处理a = 2的赋值操作的。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作a的 变量。如果是，引擎就会使用这个变量;如果否，引擎会继续查找该变量（作用域链）。
- 如果引擎最终找到了 a 变量，就会将 2 赋值给它。否则引擎就会举手示意并抛出一个异常!

#### 综上所述
是否可以认为一开始编译器编译了全局执行环境的代码，然后函数执行时，再进行函数代码的编译（延时编译？），再执行。
即在一开始编译代码，确定了根部全局执行环境，执行时进行变量赋值。如果遇到了函数调用，编译代码，生成作用域（即每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。 而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript 程序中的执行流正是由这个方便的机制控制着。可是第二次还需要编译代码吗？感觉不用，而是重新运行，创建作用域），即创建分支节点，运行时在作用域进行变量查询，然后进行赋值。

Q：作用域在编译哪个阶段形成的？
根据“遇到var a,询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中”，作用域在编译的第二个阶段之前形成的，所以是编译的第一阶段（具体见“不会断的绳子-又是这个作用域”）